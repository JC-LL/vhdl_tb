-- automatically generated by RubyRTL
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
 
library ruby_rtl;
use ruby_rtl.ruby_rtl_package.all;
 
library pgcd_lib;
use pgcd_lib.pgcd_package.all;
 
entity pgcd_c is
  port (
    reset_n : in std_logic;
    clk     : in std_logic;
    sreset  : in std_logic;
    go : in  std_logic;
    done : out std_logic;
    valid_a : in  std_logic;
    valid_b : in  std_logic;
    a : in  unsigned(31 downto 0);
    b : in  unsigned(31 downto 0);
    f : out unsigned(31 downto 0));
end pgcd_c;
 
architecture rtl of Pgcd_c is
  type gcd_state_t is (s0,s1,s2,s3);
  signal gcd_state : gcd_state_t;
  signal va : unsigned(31 downto 0);
  signal vb : unsigned(31 downto 0);
begin
 
  gcd_update : process(reset_n,clk)
  begin
    if reset_n='0' then
      gcd_state <= s0;
      va <= to_unsigned(0,32);
      vb <= to_unsigned(0,32);
      done <= '0';
    elsif rising_edge(clk) then
      if sreset='1' then
        gcd_state <= s0;
        va <= to_unsigned(0,32);
        vb <= to_unsigned(0,32);
        done <= '0';
      else 
        case gcd_state is
          when s0 =>
            if (to_uint(go,1) = 1) then
              gcd_state <= s1;
            end if;
          when s1 =>
            if (to_uint(valid_a,1) = 1) then
              va <= a;
              gcd_state <= s2;
            end if;
          when s2 =>
            if (to_uint(valid_b,1) = 1) then
              vb <= b;
              gcd_state <= s3;
            end if;
          when s3 =>
            if (va /= vb) then
              if (va < vb) then
                va <= (va - vb);
              else 
                vb <= (vb - va);
              end if;
            else 
              done <= to_bit(1,1);
              gcd_state <= s0;
            end if;
          when others =>
            null;
        end case;
      end if;
    end if;
  end process;
 
end rtl;
